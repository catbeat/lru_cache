/*  The state machine specifically for L1Cache, the following is the description
    which indicates that it uses MSI protocol */
machine(MachineType:L1Cache, "MSI Cache")
:Sequencer *sequencer;      // a piece of memory with slave port to receive message from others
 CacheMemory *cacheMemory;  // the cache memory stores the data and states
 bool send_evictions;       // used for out-of-order core when we need to evict an address so that we can operate on the load-store queue

 /* all the message data line are defined below */

 // the message buffer used for sending request to directory, the priority is 0(low)
 MessageBuffer *requestToDir, network="To", virtual_network="0", vnet_type="request";

 // the message buffer used for sending response to directory or other core's cache, the priority is 2(highest)
 MessageBuffer *responseToDirOrSibling, network="To", virtual_network="2", vnet_type="response";

 // the message buffer used for receive forward operation from directory, its priority should be 1 as it's usually activated by a previous request to directory
 MessageBuffer *forwardFromDir, network="from", virtual_network="1", vnet_type="forward";

 // the message buffer used for response sent from directory or other L1 cache, its priority is 2, too
 MessageBuffer *responseFromDirOrSibling, network="from", virtual_network="2", vnet_type="response";

 // repulsory member which gem5 transfer packet into ruby packet, used by sequencer
 MessageBuffer *mandatoryQueue;
{

    /* ------------------------------------------------------
        following part is the definition of cache entry states
        some of them is static states like I, M, some are midd-
        le/transforming states, followed by AccessPermission, 
        which indicates as its name.
    ---------------------------------------------------------*/
    state_declaration(State, desc="Cache entry states"){

        /* Invalid state */

        I,  AccessPermission:Invalid, desc="Not present/Invalid";

        IS_D, AccessPermission:Invalid, desc="from invalid to share, waiting for data";
        IM_AD, AccessPermission:Invalid, desc="from invalid to modify, waiting for acks and data, when that was M in another core's cache";
        IM_A, AccessPermission:Busy, desc="from invalid to modify, waiting  for acks";

        S, AccessPermission:Read_Only, desc="shared";

        SM_AD, AccessPermission:Read_Only, desc="from shared to modify, waiting for acks and data";
        SM_A, AccessPermission:Read_Only, desc="from shared to modify, waiting for acks";

        M, AccessPermission:Read_Write, desc="modified";

        MI_A, AccessPermission:Busy, desc="from modified to invalid, waiting for put ack";

        SI_A, AccessPermission:Busy, desc="from shared to invalid, waiting for put ack";

        II_A, AccessPermission:Invalid, desc="sent valid data before receiving put ack";
    }

    /*----------------------------------------------------------
        Event definition
    ----------------------------------------------------------*/

    enumeration(Event, desc="Cache events"){
        // from the processor or sequencer or mandatory queue
        Load,           desc="Load from processor";
        Store,          desc="Store from processor";

        Replacement,    desc="Triggered when find victim"

        FwdGetS,        desc="Directory send this to satisfy getS, it ask a cache to change M to S for response";
        FwdGetM,        desc="Directory send this to satisfy getM, it ask a cache to change M to I for resposne";
        Inv,            desc="Directory send this to invalidate a cache's shared tag";
        PutAck,         desc="Directory respond when we issue put, it avoids deadlock";

        DataDirNoAcks,  desc="Response of Data from Directory (ack = 0)";
        DataDirAcks,    desc="Response of Data from Directory (ack > 0)";

        DataOwner,      desc="Response of Data from Owner";
        InvAck,         desc="Invalidation ack after receiving Inv";

        LastInvAck,     desc="Triggered after the last ack is received"; 
    }

    structure(Entry, desc="Cache Entry", interface="AbstractCacheEntry"){
        State CacheState,   desc="the state of entry";
        DataBlock DataBlk,  desc="the block for data";
    }

    structure(TBE, desc="Transient buffer entry"){
        State TBEState,     desc="the state of block";
        DataBlock DataBlk,  desc="the block for data";
        int AckOutstanding, default=0, desc="Number of acks left to receive";
    }

    structure(TBETable, external="yes"){
        TBE lookup(Addr);
        void allocate(Addr);
        void deallocate(Addr);
        bool isPresent(Addr);
    }

    /* member function */

    TBETable TBEs, template="<L1Cache_TBE>", constructor="m_number_of_TBEs";

    Tick clockEdge();

    void set_cache_entry(AbstractCacheEntry a);
    void unset_cache_entry();
    void set_tbe(TBE b);
    void unset_tbe();

    MachineID mapAddressToMachine(Addr addr, MachineType mtype);

    Entry getCacheEntry(Addr address), return_by_pointer="yes" {
        return static_cast(Entry, "pointer", cacheMemory.lookup(address));
    }

    State getState(TBE tbe, Entry cache_entry, Addr addr){
        if (is_valid(tbe)){
            return tbe.TBEState;
        }
        else if (is_valid(cache_entry)){
            return cache_entry.CacheState;
        }
        else{
            return State:I;
        }
    }

    void setState(TBE tbe, Entry cache_entry, Addr addr, State state){
        if (is_valid(tbe)){
            tbe.TBEState := state;
        }

        if (is_valid(cache_entry)){
            cache_entry.CacheState := state;
        }
    }

    AccessPermission getAccessPermission(Addr addr){
        TBE tbe := TBEs[addr];

        // if the content is already in TBE( it's undergo changing), so the permission decide by the state of TBE entry
        if (is_valid(tbe)){
            return L1Cache_State_to_permission(tbe.TBEState);
        }

        Entry cache_entry := getCacheEntry(addr);

        // find it in cache and we get
        if (is_valid(cache_entry)){
            return L1Cache_State_to_permission(cache_entry.CacheState);
        }

        // Still in main memory
        return AccessPermission:NotPresent;
    }

    void setAccessPermission(Entry cache_entry, Addr addr, State, state){
        if (is_valid(cache_entry)){
            cache_entry.changePermission(L1Cache_State_to_permission(state));
        }
    }

    void functionalRead(Addr addr, Packet *pkt){
        TBE tbe := TBEs[addr];

        // see if it's undergoing changing
        if (is_valid(tbe)){
            testAndRead(addr, tbe.DataBlk, pkt);
        }
        else{
            testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);
        }
    }

    int functionalWrite(Addr addr, Packet *pkt){
        TBE tbe := TBEs[addr];

        // see if it's undergoing changing
        if (is_valid(tbe)){
            if (testAndWrite(addr, tbe.DataBlk, pkt)){
                return 1;
            }
            else{
                return 0;
            }
        }
        else{
            if (testAndWrite(addr, getCacheEntry(addr).DataBlk, pkt)){
                return 1;
            }
            else{
                return 0;
            }
        }
    }

    /* Input/Output network */

    /*  Here first define the output port, which is the message buffer
        defined previously, I just rename the request to directory as 
        request out, and similarly for response;

        The msg will be defined in MSI-cache-msg.sm.
    */
    out_port(request_out, RequestMsg, requestToDir);
    out_port(response_out, ResponseMsg, responseToDirOrSibling);


    /*  Here following is the input port, which listed by the pirority for
        each input port block
    */

    in_port(response_in, ResponseMsg, responseFromDirOrSibling){
        // first check whether there is msg
        if (response_in.isReady(clockEdge())){

            // I fetch the msg
            peek(response_in, ResponseMsg){
                Entry cache_entry := getCacheEntry(in_msg.addr);
                TBE tbe := TBEs[in_msg.addr];

                assert(is_valid(tbe));          // as received response, then previously the entry must be passed to TBEs

                
            }
        }
    }
}